<!DOCTYPE html>
<html>
<head>
  <title>HW6</title>
</head>

<script src="https://threejs.org/build/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/MTLLoader.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/OBJLoader.js"></script>
<script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/geometries/TeapotBufferGeometry.js"></script>

<!-- for penHolder -->
<script type="x-shader/x-vertex" id="vertexShaderDepth">
    varying vec2 vUV;
    void main() {
        vUV = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
</script>
<script type="x-shader/x-fragment" id="fragmentShaderDepth">
    uniform sampler2D texture;
    varying vec2 vUV;
    vec4 pack_depth(const in float depth) {
        const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
        const vec4 bit_mask = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
        vec4 res = fract(depth * bit_shift);
        res -= res.xxyz * bit_mask;
        return res;
    }
    void main() {
        vec4 pixel = texture2D(texture, vUV);
        if (pixel.a < 0.5) discard;
        gl_FragData[0] = pack_depth(gl_FragCoord.z);
    }
</script>

<!-- for toon shading -->
<script id="toonVertexShader" type="x-shader/x-vertex">
  uniform vec3 lightpos;
  varying float ndotl;
  varying vec3 lightdir;
  varying vec3 eyenorm;
  void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0);
    vec4 eyepos = modelViewMatrix * vec4 (position, 1.0);
    vec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);
    lightdir = lighteye.xyz - eyepos.xyz;
    eyenorm = normalMatrix * normal;
  }
</script>
<script id="toonFragmentShader" type="x-shader/x-fragment">
  varying float ndotl;
  varying vec3 lightdir;
  varying vec3 eyenorm;
  void main() {
    float nn = dot (normalize(lightdir), normalize(eyenorm));
    if (nn > 0.8) nn = 1.0;
    else if (nn > 0.6) nn = 0.6;
    else nn = 0.2;
    gl_FragColor = vec4(nn, 0.0, 0.0, 1.0);
  }
</script>

<!-- for mono -->
<script id="myVertexShader-mono" type="x-shader/x-vertex">
  varying vec2 vUv;
  void main() {
     gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0);
     vUv = uv;
  }
</script>
<script id="myFragmentShader-mono" type="x-shader/x-fragment">
  uniform sampler2D texture;
  varying vec2 vUv;

  vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
  }
  vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
  }

  void main() {
  	vec3 color = texture2D (texture, vUv).rgb;
  	vec3 hh = rgb2hsv (color);
  	hh.y = 0.0;  // set saturation to 0
  	vec3 cc = hsv2rgb (hh);
  	gl_FragColor = vec4 (cc, 1.0);
  }
</script>

<style>
	body {
    margin: 0px;
		overflow: hidden
	}
</style>

<body>
<script>
javascript:(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='https://mrdoob.github.io/stats.js/build/stats.min.js';document.head.appendChild(script);})()

  var renderer, camera, controls, scene;
  var Table, Drink;
  var materialArray = [];
  var roomLight, roomLight2, angle=0;
  var roomFlag = false, lampFlag = false;
  var pickables = [];
  var raycaster = new THREE.Raycaster();
  var mouse = new THREE.Vector2();

  var sceneGrey = new THREE.Scene(), renderTarget;

  init();
  animate();

  function init() {
    renderer = new THREE.WebGLRenderer({
      antialias: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x404040);

    renderer.autoClear = false;

    document.body.appendChild(renderer.domElement);
    camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.set(-70, 58, 70); // important
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    scene = new THREE.Scene();

    let gridXZ = new THREE.GridHelper(200, 20, 'red', 'white');

    // floor
    var loader = new THREE.TextureLoader();
    loader.setCrossOrigin ('');
    var floorTexture = loader.load('Texture/tile.jpg');
    floorTexture.wrapS = THREE.RepeatWrapping;
    floorTexture.wrapT = THREE.RepeatWrapping;
    floorTexture.repeat.set(2, 2);
    var floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200, 140, 140), new THREE.MeshLambertMaterial({
      map: floorTexture,
      side: THREE.DoubleSide
    }));
    floor.rotation.x = -Math.PI / 2;
    sceneGrey.add(floor);

    // lighting
    var light = new THREE.AmbientLight(0x505050);
    sceneGrey.add(light);

    // room light
    /*roomLight = new THREE.DirectionalLight(0xffffff);
    sceneGrey.add(roomLight);*/

    // wall
    var wallTexture = loader.load('texture/HW4/cabinet_y.png');
    var wall_negz = new THREE.Mesh(new THREE.PlaneGeometry(200, 100, 140, 140), new THREE.MeshLambertMaterial({
      map: wallTexture
    }));
    wall_negz.position.y = 50;
    var wall_posz = wall_negz.clone();
    var wall_posx = wall_negz.clone();
    var wall_negx = wall_negz.clone();
    wall_negz.position.z = -100;
    wall_posz.rotation.x = Math.PI;
    wall_posz.position.z = 100;
    wall_posz.rotation.z = Math.PI;
    wall_negx.position.x = -100;
    wall_negx.rotation.y = Math.PI / 2;
    wall_posx.position.x = 100;
    wall_posx.rotation.y = -Math.PI / 2;
    sceneGrey.add(wall_negz);
    sceneGrey.add(wall_posz);
    sceneGrey.add(wall_negx);
    sceneGrey.add(wall_posx);

		var onProgress = function(xhr) {
			if (xhr.lengthComputable) {
				var percentComplete = xhr.loaded / xhr.total * 100;
				console.log(Math.round(percentComplete, 2) + '% downloaded');
			}
		};
		var onError = function(xhr) {};
		var mtlLoader = new THREE.MTLLoader();
		mtlLoader.setPath('OBJ_Model/models/HW4/');
		mtlLoader.load('lamp.mtl', function(materials) {
			materials.preload();
			var objLoader = new THREE.OBJLoader();
			objLoader.setMaterials(materials);
			objLoader.setPath('OBJ_Model/models/HW4/');
			objLoader.load('lamp.obj', function(object) {
				let model = unitize (object, 20);
        model.position.set(-22, 30, -15);
        model.rotation.y = -Math.PI / 4;
        model.traverse (
         function (mesh) {
            if (mesh instanceof THREE.Mesh) {
            }
          }
        );
				sceneGrey.add(model);
				object.traverse (
					function(mesh) {
						if (mesh instanceof THREE.Mesh) {
							mesh.material.side = THREE.DoubleSide;
						}
				});
			}, onProgress, onError);
		});
    // chairModel
		onProgress = function(xhr) {
			if (xhr.lengthComputable) {
				var percentComplete = xhr.loaded / xhr.total * 100;
				console.log(Math.round(percentComplete, 2) + '% downloaded');
			}
		};
		onError = function(xhr) {};
		mtlLoader = new THREE.MTLLoader();
		mtlLoader.setPath('OBJ_Model/models/HW4/');
		mtlLoader.load('chair.mtl', function(materials) {
			materials.preload();
			var objLoader = new THREE.OBJLoader();
			objLoader.setMaterials(materials);
			objLoader.setPath('OBJ_Model/models/HW4/');
			objLoader.load('chair.obj', function(object) {
				let model = unitize (object, 35);
        model.position.set(-10, -5, 35);
        model.rotation.y = Math.PI;
        model.traverse (
         function (mesh) {
            if (mesh instanceof THREE.Mesh) {
            }
          }
        );
				sceneGrey.add(model);
				object.traverse (
					function(mesh) {
						if (mesh instanceof THREE.Mesh) {
							mesh.material.side = THREE.DoubleSide;
						}
				});
			}, onProgress, onError);
		});
    window.addEventListener('resize', onWindowResize, false);
    document.addEventListener('mousedown', onDocumentMouseDown, false);
    document.addEventListener('mousemove', onDocumentMouseMove, false);


    roomLight = new THREE.PointLight( 0xffffff, 1);
    roomLight.position.set( 50, 50, 50 );
    roomLight2 = new THREE.PointLight( 0xffffff, 1);
    //teapot
    let teapotMaterial = new THREE.ShaderMaterial({
      uniforms: {
        lightpos: {type:'v3', value: roomLight.position }
    },
      vertexShader: document.getElementById('toonVertexShader').textContent,
      fragmentShader: document.getElementById('toonFragmentShader').textContent
    });

    let teapot = new THREE.Mesh (new THREE.TeapotBufferGeometry(2), teapotMaterial);
    teapot.position.set(10, 32, 10);

    Table = build_table();
    Drink = build_drink();
    Drink = unitize (Drink, 8)
    Drink.position.set(0, 30, 0)

    sceneColor = new THREE.Scene();
    renderTarget = new THREE.WebGLRenderTarget (window.innerWidth, window.innerHeight);  // full-size RT

    scene0 = new THREE.Scene();
    camera0 = new THREE.OrthographicCamera (0, window.innerWidth, window.innerHeight, 0,-10,100);

    shaderMaterial = new THREE.ShaderMaterial({
      uniforms: {
        texture: {
          type: 't',
          value: renderTarget.texture
        } ,
      },
      vertexShader: document.getElementById('myVertexShader-mono').textContent,
      fragmentShader: document.getElementById('myFragmentShader-mono').textContent,

      depthTest: false,
      depthWrite: false
  });
    var plane0 = new THREE.Mesh (new THREE.PlaneGeometry(window.innerWidth, window.innerHeight), shaderMaterial);
    scene0.add (plane0);
    plane0.position.set (window.innerWidth/2, window.innerHeight/2, 0);

    sceneGrey.add(Table);
    sceneGrey.add(Drink);
    sceneColor.add(teapot);
    sceneColor.add (roomLight);
    sceneColor.add (new THREE.PointLightHelper (roomLight,5));
    sceneGrey.add (roomLight2);
  }

  function onDocumentMouseDown(event) {
    event.preventDefault();
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    // find intersections
    raycaster.setFromCamera(mouse, camera);
    var intersects = raycaster.intersectObjects(pickables, true);
    if (intersects.length > 0) {
    }
  }

  function onDocumentMouseMove(event) {
    event.preventDefault();
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    var intersects = raycaster.intersectObjects(pickables, true);
    if (intersects.length > 0) document.body.style.cursor = 'pointer';
    else document.body.style.cursor = 'auto';
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function unitize (object, targetSize) {
  // find bounding box of 'object'
  var box3 = new THREE.Box3();
  box3.setFromObject (object);
  var size = new THREE.Vector3();
  size.subVectors (box3.max, box3.min);
  var center = new THREE.Vector3();
  center.addVectors(box3.max, box3.min).multiplyScalar (0.5);
  console.log ('center: ' + center.x + ', '+center.y + ', '+center.z );
  console.log ('size: ' + size.x + ', ' +  size.y + ', '+size.z );
  // uniform scaling according to objSize
  var objSize = Math.max (size.x, size.y, size.z);
  var scaleSet = targetSize/objSize;
  var theObject =  new THREE.Object3D();
  theObject.add (object);
  object.scale.set (scaleSet, scaleSet, scaleSet);
  object.position.set (-center.x*scaleSet, -center.y*scaleSet + size.y/2*scaleSet, -center.z*scaleSet);
  return theObject;
}

  function build_table() {
  var table = new THREE.Object3D();
  //table total size 60, 30, 40
  var loader = new THREE.TextureLoader();
  loader.setCrossOrigin ('');

  var material_base = new THREE.MeshPhongMaterial({
    map: loader.load('Texture/HW4/base.png')
  });

  var material_cabinet = new THREE.MeshLambertMaterial({
    map: loader.load('Texture/HW4/cabinet.png')
  });

  var material_leg = new THREE.MeshLambertMaterial({
    map: loader.load('Texture/HW4/table_leg.png')
  });

  var base = new THREE.Mesh(new THREE.BoxGeometry(64, 4, 44), material_base);
  base.position.y = 28;

  var table_leg_1 = new THREE.Mesh(new THREE.BoxGeometry(4, 26, 4), material_leg);
  var table_leg_2 = table_leg_1.clone();
  table_leg_1.position.set(-30, 13, -20);
  table_leg_2.position.set(-30, 2, -5);
  table_leg_2.rotation.x = Math.PI / 2;

  var cabinet = new THREE.Mesh(new THREE.BoxGeometry(22, 26, 42), material_cabinet);
  cabinet.position.set(21, 13, -1);

  table.add(base);
  table.add(table_leg_1);
  table.add(table_leg_2);
  table.add(cabinet);

  return table;
}

  function build_drink(){
  var drink = new THREE.Object3D();
  var loader = new THREE.TextureLoader();
  loader.setCrossOrigin ('');

  var geometry = new THREE.Geometry();
  geometry.vertices.push(
    new THREE.Vector3(-10, 0, -10),
    new THREE.Vector3(-10, 0, 10),
    new THREE.Vector3(10, 0, 10),
    new THREE.Vector3(10, 0, -10),
    new THREE.Vector3(-10, 28, -10),
    new THREE.Vector3(-10, 28, 10),
    new THREE.Vector3(10, 28, 10),
    new THREE.Vector3(10, 28, -10),
    new THREE.Vector3(-10, 28+Math.sqrt(21), 0),
    new THREE.Vector3(10, 28+Math.sqrt(21), 0)
  );

  var face;
  face = new THREE.Face3(3, 0, 7); face.materialIndex = 0;
  geometry.faces.push(face);
  face = new THREE.Face3(0, 4, 7); face.materialIndex = 0;
  geometry.faces.push(face);
  face = new THREE.Face3(1, 5, 4); face.materialIndex = 1;
  geometry.faces.push(face);
  face = new THREE.Face3(0, 1, 4); face.materialIndex = 1;
  geometry.faces.push(face);
  face = new THREE.Face3(1, 2, 5); face.materialIndex = 2;
  geometry.faces.push(face);
  face = new THREE.Face3(2, 6, 5); face.materialIndex = 2;
  geometry.faces.push(face);
  face = new THREE.Face3(2, 3, 6); face.materialIndex = 3;
  geometry.faces.push(face);
  face = new THREE.Face3(3, 7, 6); face.materialIndex = 3;
  geometry.faces.push(face);
  face = new THREE.Face3(7, 4, 9); face.materialIndex = 4;
  geometry.faces.push(face);
  face = new THREE.Face3(4, 8, 9); face.materialIndex = 4;
  geometry.faces.push(face);
  face = new THREE.Face3(4, 5, 8); face.materialIndex = 5;
  geometry.faces.push(face);
  face = new THREE.Face3(6, 9, 8); face.materialIndex = 6;
  geometry.faces.push(face);
  face = new THREE.Face3(5, 6, 8); face.materialIndex = 6;
  geometry.faces.push(face);
  face = new THREE.Face3(6, 7, 9); face.materialIndex = 7;
  geometry.faces.push(face);

  geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(0, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(0, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(0, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(0, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(0, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(0, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(0, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)]);

  geometry.computeFaceNormals();
  geometry.computeVertexNormals();

  materialArray.push(new THREE.MeshPhongMaterial({
    map : loader.load('Texture/HW4/drink_pz.jpg'),
    side : THREE.DoubleSide
  }))
  materialArray.push(new THREE.MeshPhongMaterial({
    map : loader.load('Texture/HW4/drink_px.jpg')
  }))
  materialArray.push(new THREE.MeshPhongMaterial({
    map : loader.load('Texture/HW4/drink_nz.jpg')
  }))
  materialArray.push(new THREE.MeshPhongMaterial({
    map : loader.load('Texture/HW4/drink_nx.jpg')
  }))
  materialArray.push(new THREE.MeshPhongMaterial({
    map : loader.load('Texture/HW4/drink_up_pz.jpg')
  }))
  materialArray.push(new THREE.MeshPhongMaterial({
    map : loader.load('Texture/HW4/drink_up_px.jpg')
  }))
  materialArray.push(new THREE.MeshPhongMaterial({
    map : loader.load('Texture/HW4/drink_up_nz.jpg')
  }))
  materialArray.push(new THREE.MeshPhongMaterial({
    map : loader.load('Texture/HW4/drink_up_nx.jpg')
  }))

  drink.add(new THREE.Mesh(geometry, materialArray));
  return drink;
}

  function animate() {
    angle += 0.01;
    requestAnimationFrame(animate);
    roomLight.position.set (40*Math.cos(angle), 60, 40*Math.sin(angle));
    roomLight2.copy (roomLight);
    //controls.update();

    renderer.setRenderTarget (renderTarget);
    renderer.clear();  // clear the buffers of render target

    // normalMat.colorWrite = true;
    sceneGrey.traverse ( function (obj) {
      if (obj instanceof THREE.Mesh)
        obj.material.colorWrite = true;
    });
    Drink.traverse (
      function(mesh) {
        if (mesh instanceof THREE.Mesh) {
            for(let i = 0; i < materialArray.length; i++){
              mesh.material[i].colorWrite = true;
            }
        }
    });

    renderer.render(sceneGrey, camera);

   // switch to screen output
    renderer.setRenderTarget (null);
    renderer.clearColor();  // clear screen buffers
    renderer.render(scene0, camera0);

   // set up blockers from sceneGrey (colorWrite is disabled)
   // normalMat.colorWrite = false;
    sceneGrey.traverse ( function (obj) {
      if (obj instanceof THREE.Mesh)
        obj.material.colorWrite = false;
    });
    Drink.traverse (
      function(mesh) {
        if (mesh instanceof THREE.Mesh) {
            for(let i = 0; i < materialArray.length; i++){
              mesh.material[i].colorWrite = false;
            }
          }
        });
    renderer.render (sceneGrey, camera);

   // render sceneColor
    renderer.render(sceneColor, camera);
  }
</script>

</body>
</html>
