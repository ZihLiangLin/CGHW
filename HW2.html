<!DOCTYPE html>

<html>

<head>
<style>
  body {
  background-color: #fff;
  color: #111;
  margin: 0px;
  overflow: hidden;
  font-family: Monospace;
  font-size: 10px;
  position: absolute;
  }

  #info {
  position: absolute;
  top: 3%;
  width: 100%;
  padding: 5px;
  text-align: center;
  color: #ffff00;
  }

</style>
</head>

<body>
  <div id="info">CG HW2</div>
  <script src="https://threejs.org/build/three.min.js"></script>
  <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/MTLLoader.js"></script>
  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/OBJLoader.js"></script>

<script>
var renderer, camera, controls, scene;
var Aladdin = [];
var localPlane = new THREE.Plane( new THREE.Vector3( 0,  1, 0 ), -160 );
var localPlane2 = new THREE.Plane( new THREE.Vector3( 0,  -1, 0 ), 160 );

init();
animate();

function init() {
  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x888888);
  document.body.appendChild(renderer.domElement);

  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
  camera.position.set(500, 200, 300)

  controls = new THREE.OrbitControls(camera, renderer.domElement);

  scene = new THREE.Scene();

  var dLight = new THREE.DirectionalLight(0xffffff);
  scene.add( dLight );

  var aLight = new THREE.AmbientLight( 0x404040 );
  scene.add( aLight );

  window.addEventListener('resize', onWindowResize, false);

  ///////////////////////////////////////////////////////////////////////////////////////////////
  //floor
  var loader = new THREE.TextureLoader();
	loader.setCrossOrigin('');
  var texture = loader.load(
    // resource URL
    'https://zihlianglin.github.io/CGHW/Texture/grass.jpg'
  )
  var floor = new THREE.Mesh(new THREE.PlaneGeometry(5000, 5000, 500), new THREE.MeshPhongMaterial({map: texture, side: THREE.DoubleSide}));
  texture.repeat.set( 20, 20 );
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  scene.add(floor);
  floor.rotation.x = Math.PI/2
  floor.position.y = -1;

  // model
	var onProgress = function ( xhr ) {
		if ( xhr.lengthComputable ) {
			var percentComplete = xhr.loaded / xhr.total * 100;
			console.log( Math.round( percentComplete, 2 ) + '% downloaded' );
		}
	};
	var onError = function () {};

	var mtlLoader = new THREE.MTLLoader();
	mtlLoader.load( 'OBJ_Model/Aladdin/Aladdin.mtl', function ( materials ) {
		materials.preload();
		var objLoader = new THREE.OBJLoader()
			objLoader.setMaterials( materials )
			objLoader.load( 'OBJ_Model/Aladdin/Aladdin.obj', function ( object ) {
        //Aladdin.add(unitize (object, 50));
        scene.add(object);
        object.traverse (
	        function(mesh) {
		        if (mesh instanceof THREE.Mesh) {
			        mesh.material.side = THREE.DoubleSide;
              Aladdin.push(mesh);
		        }
        });
		  }, onProgress, onError );
	});

  ////////////////////////////////////////////////////////////////////////////////

  
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
	render();
  requestAnimationFrame(animate);

  //Aladdin.children[0].material.clippingPlanes = [ localPlane ]
  //Aladdin.children[1].material.clippingPlanes = [ localPlane2 ]

  //Aladdin.rotation.y += 0.01;

  renderer.localClippingEnabled = true;
}

function render(){
	renderer.render (scene, camera);
}

function unitize (object, targetSize) {
		// find bounding box of 'object'
		var box3 = new THREE.Box3();
		box3.setFromObject (object);
		var size = new THREE.Vector3();
		size.subVectors (box3.max, box3.min);
		var center = new THREE.Vector3();
		center.addVectors(box3.max, box3.min).multiplyScalar (0.5);
		console.log ('center: ' + center.x + ', '+center.y + ', '+center.z );
		console.log ('size: ' + size.x + ', ' +  size.y + ', '+size.z );
		// uniform scaling according to objSize
		var objSize = Math.max (size.x, size.y, size.z);
		var scaleSet = targetSize/objSize;
		var theObject =  new THREE.Object3D();
		theObject.add (object);
		object.scale.set (scaleSet, scaleSet, scaleSet);
		object.position.set (-center.x*scaleSet, -center.y*scaleSet + size.y/2*scaleSet, -center.z*scaleSet);
		theObject.rotation.y = Math.PI/2;
		return theObject;
	}

</script>
</body>

</html>
