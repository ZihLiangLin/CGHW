<!DOCTYPE html>

<html>

<head>
<style>
  body {
  background-color: #fff;
  color: #111;
  margin: 0px;
  overflow: hidden;
  font-family: Monospace;
  font-size: 10px;
  position: absolute;
  }
  #info {
  position: absolute;
  top: 3%;
  width: 100%;
  padding: 5px;
  text-align: center;
  color: #ffff00;
  }
</style>
</head>

<body>
  <div id="info">CG HW2</div>
  <script src="https://threejs.org/build/three.min.js"></script>
  <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/MTLLoader.js"></script>
  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/OBJLoader.js"></script>

<script>
//建立多個models可以解決1母多子的情況
var renderer, camera, controls, scene;
var a1 = new THREE.Object3D(), a2 = new THREE.Object3D(), a3 = new THREE.Object3D();
var head = new THREE.Plane( new THREE.Vector3( 0,  -1, 0 ), 114 );
var head2 = new THREE.Plane( new THREE.Vector3( 0,  1, 0 ), -114 );
var rArm = new THREE.Plane( new THREE.Vector3( -1,  0, 0 ), -19 );
var rArm2 = new THREE.Plane( new THREE.Vector3( 1,  0, 0 ), 19 );
var lArm = new THREE.Plane( new THREE.Vector3( -1,  0, 0 ), 19);
var lArm2 = new THREE.Plane( new THREE.Vector3( 1,  0, 0 ), -19 );
var rLeg = new THREE.Plane( new THREE.Vector3( -1,  0, 0 ), -1 );
var rLeg2 = new THREE.Plane( new THREE.Vector3( 1,  0, 0 ), 1 );
var lLeg = new THREE.Plane( new THREE.Vector3( -1,  0, 0 ), 1 );
var lLeg2 = new THREE.Plane( new THREE.Vector3( 1,  0, 0 ), -1 );

init();
animate();
function init() {
  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x888888);
  document.body.appendChild(renderer.domElement);
  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
  camera.position.set(500, 200, 300)
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  scene = new THREE.Scene();
  var dLight = new THREE.DirectionalLight(0xffffff);
  scene.add( dLight );
  var aLight = new THREE.AmbientLight( 0x404040 );
  scene.add( aLight );
  window.addEventListener('resize', onWindowResize, false);
  ///////////////////////////////////////////////////////////////////////////////////////////////
  //floor
  var loader = new THREE.TextureLoader();
	loader.setCrossOrigin('');
  var texture = loader.load(
    // resource URL
    'https://zihlianglin.github.io/CGHW/Texture/grass.jpg'
  )
  var floor = new THREE.Mesh(new THREE.PlaneGeometry(5000, 5000, 500), new THREE.MeshPhongMaterial({map: texture, side: THREE.DoubleSide}));
  texture.repeat.set( 20, 20 );
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  scene.add(floor);
  floor.rotation.x = Math.PI/2;
  floor.position.y = -0.2;
  // model
	var onProgress = function ( xhr ) {
		if ( xhr.lengthComputable ) {
			var percentComplete = xhr.loaded / xhr.total * 100;
			console.log( Math.round( percentComplete, 2 ) + '% downloaded' );
		}
	};
	var onError = function () {};
	var mtlLoader = new THREE.MTLLoader();
	mtlLoader.load( 'OBJ_Model/Aladdin/Aladdin.mtl', function ( materials ) {
		materials.preload();
		var objLoader = new THREE.OBJLoader()
			objLoader.setMaterials( materials )
			objLoader.load('OBJ_Model/Aladdin/Aladdin.obj', function ( object ) {
        //a1.add(unitize (object, 50));
        a1.copy(object);
        scene.add(a1);
        a1.position.x = -5
        object.traverse (
	        function(mesh) {
		        if (mesh instanceof THREE.Mesh) {
			        mesh.material.side = THREE.DoubleSide;
		        }
        });
		  }, onProgress, onError );
	});
  mtlLoader.load( 'OBJ_Model/Aladdin/Aladdin.mtl', function ( materials ) {
		materials.preload();
		var objLoader = new THREE.OBJLoader()
			objLoader.setMaterials( materials )
			objLoader.load('OBJ_Model/Aladdin/Aladdin.obj', function ( object ) {
        //a2.add(unitize (object, 50));
        a2.copy(object);
        scene.add(a2);
        a2.position.x = -5
        object.traverse (
	        function(mesh) {
		        if (mesh instanceof THREE.Mesh) {
			        mesh.material.side = THREE.DoubleSide;
		        }
        });
		  }, onProgress, onError );
	});
  mtlLoader.load( 'OBJ_Model/Aladdin/Aladdin.mtl', function ( materials ) {
		materials.preload();
		var objLoader = new THREE.OBJLoader()
			objLoader.setMaterials( materials )
			objLoader.load('OBJ_Model/Aladdin/Aladdin.obj', function ( object ) {
        //a3.add(unitize (object, 50));
        a3.copy(object);
        scene.add(a3);
        a3.position.x = -5
        object.traverse (
	        function(mesh) {
		        if (mesh instanceof THREE.Mesh) {
			        mesh.material.side = THREE.DoubleSide;
		        }
        });
		  }, onProgress, onError );
	});
  ////////////////////////////////////////////////////////////////////////////////
}
function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
function animate() {
	render();
  requestAnimationFrame(animate);
  //head
  a1.children[0].material.clippingPlanes =  [head2, rArm2, lArm] ;
  a1.children[1].material.clippingPlanes =  [head2, rArm2, lArm] ;
  a2.children[0].material.clippingPlanes =  [head2, rArm, lArm] ;
  a2.children[1].material.clippingPlanes =  [head2, rArm, lArm] ;
  a3.children[0].material.clippingPlanes =  [head2, rArm2, lArm2] ;
  a3.children[1].material.clippingPlanes =  [head2, rArm2, lArm2] ;

  //a1.children[0].rotation.y += 0.01;
  //a1.children[1].rotation.y += 0.01;
  //a2.children[0].rotation.y += 0.01;
  //a2.children[1].rotation.y += 0.01;
  renderer.localClippingEnabled = true;
}
function render(){
	renderer.render (scene, camera);
}
function unitize (object, targetSize) {
		// find bounding box of 'object'
		var box3 = new THREE.Box3();
		box3.setFromObject (object);
		var size = new THREE.Vector3();
		size.subVectors (box3.max, box3.min);
		var center = new THREE.Vector3();
		center.addVectors(box3.max, box3.min).multiplyScalar (0.5);
		console.log ('center: ' + center.x + ', '+center.y + ', '+center.z );
		console.log ('size: ' + size.x + ', ' +  size.y + ', '+size.z );
		// uniform scaling according to objSize
		var objSize = Math.max (size.x, size.y, size.z);
		var scaleSet = targetSize/objSize;
		var theObject =  new THREE.Object3D();
		theObject.add (object);
		object.scale.set (scaleSet, scaleSet, scaleSet);
		object.position.set (-center.x*scaleSet, -center.y*scaleSet + size.y/2*scaleSet, -center.z*scaleSet);
		theObject.rotation.y = Math.PI/2;
		return theObject;
	}
</script>
</body>

</html>
